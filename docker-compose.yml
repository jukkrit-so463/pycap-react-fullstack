version: '3.8' # ระบุ Docker Compose version

services:
  # Node.js Backend Service
  backend:
    build:
      context: ./soap-login-server # ระบุ path ของ Dockerfile context
      dockerfile: Dockerfile       # ระบุชื่อ Dockerfile
    container_name: soap-login-backend # กำหนดชื่อ Container ให้ชัดเจน
    ports:
      - "5000:5000" # Host_Port:Container_Port - Backend จะรันบนพอร์ต 5000 ทั้งบน Host และใน Container
    environment:
      # Environment Variables สำหรับ Node.js Backend เพื่อเชื่อมต่อ MySQL และ JWT
      MYSQL_HOST: db                  # ชี้ไปที่ชื่อ Service ของ MySQL ใน Docker Compose network
      MYSQL_USER: ${DB_USER}          # ดึงค่าจากไฟล์ .env
      MYSQL_PASSWORD: ${DB_PASSWORD}  # ดึงค่าจากไฟล์ .env
      MYSQL_DATABASE: ${DB_DATABASE}  # ดึงค่าจากไฟล์ .env
      JWT_SECRET: ${JWT_SECRET}       # ดึงค่าจากไฟล์ .env
      NODE_ENV: production            # ตั้งค่าเป็น production เพื่อประสิทธิภาพและความปลอดภัย
    depends_on:
      db:
        condition: service_healthy
    networks:
      - app_network # เชื่อมต่อกับ Network ที่กำหนดเอง
    restart: always # กำหนดให้ Container รันใหม่เสมอหากหยุดทำงาน

  # React Frontend Service (Served by Nginx)
  frontend:
    build:
      context: ./soap-login # ระบุ path ของ Dockerfile context
      dockerfile: Dockerfile    # ระบุชื่อ Dockerfile
    container_name: soap-login-frontend # กำหนดชื่อ Container ให้ชัดเจน
    ports:
      - "80:80" # Host_Port:Container_Port - Frontend (Nginx) จะรันบนพอร์ต 80
    environment:
      # สำหรับ React (Create React App) ที่ต้องทราบ URL ของ Backend API
      # เนื่องจากจะใช้ Nginx Reverse Proxy, Frontend จะเรียก API ผ่าน path /api
      REACT_APP_BACKEND_URL: /api
      # SOAP service configuration
      REACT_APP_SOAP_SERVICE_URL: http://10.106.0.210
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      - backend # Frontend จะเริ่มหลังจาก Backend พร้อมใช้งาน (เพื่อให้มั่นใจว่า API พร้อม)
    networks:
      - app_network # เชื่อมต่อกับ Network ที่กำหนดเอง
    restart: always # กำหนดให้ Container รันใหม่เสมอหากหยุดทำงาน

  # MySQL Database Service
  db:
    image: mysql:8.0
    container_name: soap-login-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql-init:/docker-entrypoint-initdb.d
    networks:
      - app_network
    command: --default-authentication-plugin=mysql_native_password # << เพิ่มบรรทัดนี้!
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u$$MYSQL_USER", "-p$$MYSQL_PASSWORD"]
      timeout: 20s
      retries: 10
      start_period: 60s # รักษาค่านี้ไว้
      interval: 5s

# Docker Volumes สำหรับเก็บข้อมูลถาวร
volumes:
  mysql_data: # Volume สำหรับข้อมูล MySQL

# Docker Networks สำหรับให้ Services สื่อสารกัน
networks:
  app_network:
    driver: bridge # ใช้ Bridge network
